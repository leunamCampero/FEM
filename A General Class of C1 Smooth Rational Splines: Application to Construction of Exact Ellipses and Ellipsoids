"""
Created on Wed Feb  9 23:15:27 2022

@author: mcamperojurado

References:

1.- A Tchebychefian Extension Of Multidegree B-Splines: Algorithmic Computation and Properties.

2.- A General Class of C1 Smooth Rational Splines: Application to Construction of Exact Ellipses and Ellipsoids.

3.- Approximation Theory XV: San Antonio 2016. Generalized B-Splines in Isogeometric Analysis 
Carla Manni, Fabio Roman and Hendrik Speleers pg 239.


"""



import matplotlib.pyplot as plt
import numpy as np
import random
import sys
from scipy.linalg import block_diag
        
    
def B_B_S(x, p, i, xi):
    '''
    Compute the b_{j,p} basis of the B-spline Space
    Read ref**3 pg 2.
    '''
    if (p == 0):
        if (xi[i] <= x <= xi[i+1]):
            return 1
        else:
            return 0
    if (xi[i] == xi[i+p]):
        s1 = 0
    else:
        s1 = ((x-xi[i])/(xi[i+p]-xi[i]))*B_B_S(x, p-1, i, xi)
    if (xi[i+p+1] == xi[i+1]):
        s2 = 0
    else:
        s2 = ((xi[i+p+1]-x)/(xi[i+p+1]-xi[i+1]))*B_B_S(x, p-1, i+1, xi)
    return s1 + s2

def plot_B_B_S(p, xi, lt):
    '''
    Plot b_{j,p} (the basis of the B-spline Space) of degree p
    '''
    j = len(xi)-p-1
    q =  np.linspace(min(xi), max(xi), lt, endpoint=True)
    for pp in range(p+1):
        for jj in range(j):
            v = []
            for i in range(len(q)):
                if (pp == p):
                    v.append(B_B_S(q[i], pp, jj , xi))
            if (pp == p):
                plt.plot(q, v)
    return plt.show()

def plot_B_B_S_1(p, xi, lt):
    '''
    Plot b_{j,q} (the basis of the B-spline Space) of all degrees q <= p.
    '''
    j = len(xi)-p-1
    q =  np.linspace(min(xi), max(xi), lt, endpoint=True)
    for pp in range(p+1):
        for jj in range(j):
            v = []
            for i in range(len(q)):
                v.append(B_B_S(q[i], pp, jj , xi))
            plt.plot(q, v)
    return plt.show() 

def made_B_S(x, p, coef, xi):
    '''
    Make a general element of the space generated by b_{j,p}, i.e. <b_{j,p}: j= 1,...,n>
    '''
    n = len(xi)-p-1
    assert (n >= p+1) and (len(coef) >= n),"Dimensions not coincide"
    return sum(coef[i]*B_B_S(x, p, i, xi) for i in range(n))


def NURBS(x, p, xi, we, j, n):
    '''
    Make a basis NURBS (Non-uniform rational B-splines) b_{j,p}^{w}, i.e. {b_{j,p}^{w}: j= 1,...,n}
    Read ref**3 pg 2.
    '''
    if (n >= p + 1): 
        quot = sum(we[i]*B_B_S(x, p, i, xi) for i in range(n))
        return (we[j]*B_B_S(x, p, j, xi))/quot
        
    
def n_weight_vector(n):
    '''
    Make n random weights to test the NURBS function
    '''
    eps = eps = sys.float_info.epsilon
    return [random.uniform(eps,1) for i in range(n)]

def plot_NURBS_1(p, xi, lt, we):
    '''
    Plot b_{j,p}^{w} (the basis of the NURBS-Space) of degree all the degrees
    '''
    xc = np.linspace(min(xi), max(xi), lt, endpoint=True)
    yc = []
    n = len(xi)-p-1
    for j in range(n):
        yc = [NURBS(xc[i], p, xi, we, j, n) for i in range(len(xc))]
        plt.plot(xc, yc)
    plt.show()

def plot_NURBS(p, xi, lt, we):
    '''
    Plot b_{j,p}^{w} (the basis of the NURBS-Space) of degree  p.
    '''
    xc = np.linspace(min(xi), max(xi), lt, endpoint=True)
    for pp in range(p+1):
        yc = []
        n = len(xi)-pp-1
        for j in range(n):
            if (pp == p):
                yc = [NURBS(xc[i], pp, xi, we, j, n) for i in range(len(xc))]
                plt.plot(xc, yc)
    return plt.show()

def l_sorted(l):
    '''
    Function created with the aim to check that I am filling the b vector (see ref**2 pg 4)
    in the correct way
    '''
    v = []
    for i in range(len(l)):
        m = min(l)
        v.append(m)
        l.remove(m)
    return v

# def p_1_xi(p, iv, fv):
#     v = [iv for i in range(p+1)]
#     for i in range(p+1): v.append(fv)
#     return v
    
def phi_i(x, x1, x2, i, tau_1):
    '''
    See ref**2 pg 4, eq (5)
    '''
    return x-x1[i]+tau_1+sum(x2[j]-x1[j] for j in range(i))

# def phi_i_v(v, x1, x2, tau_1):
#     w1 = []
#     for i in range(len(v)):
#         w2 = []
#         for j in range(len(v[i])):
#             w2.append(v[i][j]-x1[i]+tau_1+sum(x2[r]-x1[r] for r in range(i)))
#         w1.append(w2)
#     return w1
    
def get_n(vxi, vp):
    '''
    Function to obtain m^{i} = len(xi)-p^{i}-1 when we are considering Rational
    multi-degree B-splines
    '''
    return [len(vxi[i])-vp[i]-1 for i in range(len(vp))]

def mu_i(vn, i):
    '''
    Function to obtain the cumulative local dimension
    See ref**2 pg 4
    '''
    return 0 if i == 0 else sum(vn[j] for j in range(i))

def eta_i(vn, i):
    '''
    Function to obtain eta
    See ref**2 pg 4
    '''
    return 0 if i == 0 else sum(vn[j]-2 for j in range(i))

def alpha_i(p, x2, xi, w, w_l_1):
    '''
    Function to obtain alpha^{i}
    See ref**2 pg 4
    '''
    return (p/(x2-xi))*(w_l_1/(w))

def beta_i(p_p_1, x1, xi, w1, w2):
    '''
    Function to obtain beta^{i}
    See ref**2 pg 4
    '''
    return (p_p_1/(xi-x1))*(w2/(w1))

def sum_e_c(M):
    '''
    Function to check if the columns of a given matrix sums to 1,
    remember that we need this to get a DTA-compatible Extraction matrix
    See ref**3 pg 2, definition 1.1.
    '''
    n, m = M.shape
    for i in range(m):
        s = 0
        for j in range(n):
            s = s + M[j,i]
        if (s != 1.0):
            return False
    return True
            
def H_ext(vxi, vp, vwe):
    '''
    Function to compute the extraction matrices H, H^{per}
    See ref**2 pg 5, eq (7), (8) and (9)
    '''
    vn = get_n(vxi, vp)
    m = len(vp)
    if (m > 1):
        x1 = [min(xi) for xi in vxi]
        x2 = [max(xi) for xi in vxi]
        vn = get_n(vxi, vp)
        eta_m = eta_i(vn, m)
        mu_m = mu_i(vn, m) - 2
        H_c = np.zeros((eta_m, mu_m), dtype=np.float64)
        v_alp = [(vp[i]/(x2[i]-vxi[i][vn[i]-1]))*(vwe[i][vn[i]-2]/vwe[i][vn[i]-1]) for i in range(m-1)]
        v_bet = [(vp[i+1]/(vxi[i+1][vp[i+1]+1]-x1[i+1]))*(vwe[i+1][1]/vwe[i+1][0]) for i in range(m-1)]
        for i in range(m):
            for j in range(vn[i]-2):
                H_c[eta_i(vn,i)+j, mu_i(vn,i)+j] = 1
        for i in range(m-1):
            H_c[eta_i(vn, i+1)-1, mu_i(vn, i+1)-2] = v_alp[i]/(v_alp[i]+v_bet[i])
            H_c[eta_i(vn, i+1)-1, mu_i(vn, i+1)-1] = v_alp[i]/(v_alp[i]+v_bet[i])
            H_c[eta_i(vn, i+1), mu_i(vn, i+1)-2] = v_bet[i]/(v_alp[i]+v_bet[i])
            H_c[eta_i(vn, i+1), mu_i(vn, i+1)-1] = v_bet[i]/(v_alp[i]+v_bet[i])
        a = np.zeros((1,eta_m+2))
        a[0, 0] = 1
        H_col = np.concatenate((np.concatenate((np.zeros((1,mu_m)), H_c), axis=0),np.zeros((1,mu_m))), axis = 0)
        b = np.zeros((1, eta_m+2))
        b[0,eta_m+1] = 1
        H = np.concatenate((np.concatenate((a.T, H_col), axis = 1), b.T), axis = 1)
        H_per = np.concatenate((np.concatenate((np.zeros((1,eta_m)).T, H_c), axis=1),np.zeros((1,eta_m)).T), axis = 1)
        H_per[0,0] = H_per[0,mu_m+1] = v_bet[0]/(v_alp[0]+v_bet[0])
        H_per[eta_m-1,0] = H_per[eta_m-1,mu_m+1] = v_alp[0]/(v_alp[0]+v_bet[0])
        return H, H_per
    else:
        x1 = [min(xi) for xi in vxi]
        x2 = [max(xi) for xi in vxi]
        vn = get_n(vxi, vp)
        eta_m = eta_i(vn, m)
        mu_m = mu_i(vn, m) - 2
        H_c = np.zeros((eta_m, mu_m), dtype=np.float64)
        for i in range(m):
            for j in range(vn[i]-2):
                H_c[eta_i(vn,i)+j, mu_i(vn,i)+j] = 1
        a = np.zeros((1,eta_m+2))
        a[0, 0] = 1
        H_col = np.concatenate((np.concatenate((np.zeros((1,mu_m)), H_c), axis=0),np.zeros((1,mu_m))), axis = 0)
        b = np.zeros((1, eta_m+2))
        b[0,eta_m+1] = 1
        H = np.concatenate((np.concatenate((a.T, H_col), axis = 1), b.T), axis = 1)
        return H, H_c
        

def get_tau(x1, x2, tau_1):
    '''
    Function to compute phi^{i}(x_{1}^{i}) and phi^{i}(x_{2}^{i}) for i=1,...,m.
    See ref**2 pg 5, eq (7), (8) and (9)
    '''
    vtau_1 = [phi_i(x1[i], x1, x2, i, tau_1) for i in range(len(x1))]
    vtau_2 = [phi_i(x2[i], x1, x2, i, tau_1) for i in range(len(x2))]
    return vtau_1, vtau_2


def s_b_mu(x, vp, vxi, tau_1, vwe, i, j):
    '''
    Compute vector b of length mu_{m}
    See ref**2, pg 4
    '''
    vn = get_n(vxi, vp)
    m = len(vp)
    x1 = [min(xi) for xi in vxi]
    x2 = [max(xi) for xi in vxi]
    vtau_1, vtau_2 = get_tau(x1, x2, tau_1)
    # print(x, vtau_1[i], phi_i(x, x1, x2, i, tau_1), vtau_2[i])
    if (vtau_1[i] <= phi_i(x, x1, x2, i, tau_1) <= vtau_2[i]):
        return NURBS(x, vp[i], vxi[i], vwe[i], j, vn[i])
    # elif ((i != m-1) and (phi_i(x, x1, x2, i, tau_1) == vtau_2[i])):
    elif ((i == m-1) and (phi_i(x, x1, x2, i, tau_1) == vtau_2[m-1])):
        return NURBS(x2[i], vp[i], vxi[i], vwe[i], j, vn[i])
    else:
        return 0
    
def get_matrix_b_mu(vp, vxi, tau_1, vwe, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb
    '''
    vn = get_n(vxi, vp)
    m = len(vxi)
    x1 = [min(xi) for xi in vxi]
    x2 = [max(xi) for xi in vxi]
    vtau_1, vtau_2 = get_tau(x1, x2, tau_1)
    ct = []
    Mb = []
    for i in range(m):
        xc = np.linspace(x1[i], x2[i], lt, endpoint=True)
        for x in xc:
            ct.append(phi_i(x, x1, x2, i, tau_1))
    for i in range(m):
        for j in range(vn[i]):
            ptc = []
            for k in range(m):
                xc = np.linspace(x1[k], x2[k], lt, endpoint=True)
                if (k == i):
                    for x in xc:
                        ptc.append(s_b_mu(x, vp, vxi, tau_1, vwe, k, j))
                else:
                    for x in xc:
                        ptc.append(0)
            Mb.append(ptc)
    return np.array(Mb), ct
    
    
    
def plot_s_b_mu(vp, vxi, tau_1, vwe, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb, and plot it
    '''
    vn = get_n(vxi, vp)
    m = len(vxi)
    x1 = [min(xi) for xi in vxi]
    x2 = [max(xi) for xi in vxi]
    vtau_1, vtau_2 = get_tau(x1, x2, tau_1)
    ct = []
    for i in range(m):
        xc = np.linspace(x1[i], x2[i], lt, endpoint=True)
        for x in xc:
            ct.append(phi_i(x, x1, x2, i, tau_1))
    for i in range(m):
        for j in range(vn[i]):
            ptc = []
            for k in range(m):
                xc = np.linspace(x1[k], x2[k], lt, endpoint=True)
                if (k == i):
                    for x in xc:
                        ptc.append(s_b_mu(x, vp, vxi, tau_1, vwe, k, j))
                else:
                    for x in xc:
                        ptc.append(0)
            plt.plot(ct, ptc)
    plt.show()    
    
 
def plott_b_mu_H(vp, vxi, tau_1, vwe, lt):
    HM, H_per = H_ext(vxi, vp, vwe)
    Mb, ct = get_matrix_b_mu(vp, vxi, tau_1, vwe, lt)
    MB = np.array(H_per).dot(Mb)
    nr, nc = MB.shape
    for i in range(nr):
        plt.plot(ct, MB[i,:])
    plt.show()
    
def plot_ellipse(vp, vxi, tau_1, lt, vwe, rp):
    '''
    Plot circles and ellipses using C^{1} rational splines
    See ref**2, pg 6, subsection 2.4
    '''
    HM, H_per = H_ext(vxi, vp, vwe)
    Mb, ct = get_matrix_b_mu(vp, vxi, tau_1, vwe, lt)
    MB = np.array(H_per).dot(Mb)
    nr, nc = MB.shape
    xcp = []
    ycp = []
    xc = [rp[i][0] for i in range(nr)]
    yc = [rp[i][1] for i in range(nr)]
    xc.append(rp[0][0])
    yc.append(rp[0][1])
    for i in range(nc):
        ft = np.array([0,0])
        for j in range(nr):
            ft = ft + rp[j]*MB[j,i]
        xcp.append(ft[0])
        ycp.append(ft[1])
    plt.plot(xcp, ycp)
    plt.plot(xc, yc)
    plt.scatter(xc, yc)
    return plt.show()


def get_rho(nt, j):
    '''
    Function to compute rho_{j}
    See ref 2** pg8, eq(19)
    '''
    return (j-1)/(nt-1)

def get_theta(ns, i):
    '''
    Function to compute theta_{i}
    See ref 2** pg 8, eq (20)
    '''
    return (2*np.pi)+(1-2*i)*np.pi/ns

def get_E_col(i, ns):
    '''
    Function to compute the columns of the extraction matrix E_bar
    See ref 2** pg 10, eq (31)
    '''
    AE = np.array([[1/3,0,1/3],[-1/6,np.sqrt(3)/6,1/3],[-1/6,-np.sqrt(3)/6,1/3]])
    b = np.zeros((3,1))
    b[0,0] = np.cos(get_theta(ns, i))
    b[1,0] = np.sin(get_theta(ns, i))
    b[2,0] = 1
    return AE.dot(b)

def E_bar(vxi, vp, ns):
    '''
    Function to compute the extraction matrix E_bar
    See ref 2** pg 10, eq (31)
    '''
    # ep = (np.sqrt(3)+1)/6
    # el = (np.sqrt(3)-1)/6
    # EM = np.array([[1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3],[1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3],[1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3]])
    # EM = EM + (1/np.sqrt(2))*np.array([[0,0,0,0,1/3,-1/3,-1/3,1/3],[0,0,0,0,-ep,-el,ep,el],[0,0,0,0,el,ep,-el,-ep]])
    EM = np.zeros((3, ns))
    for i in range(3):
        for j in range(ns):
            EM[i,j] = 1/3
    for i in range(ns):
        EM = np.concatenate((EM, get_E_col(i+1, ns)), axis=1)
    # print(EM)
    return EM
        
def anti_diagonal(k):
    '''
    Function to compute the extraction matrix E_bar
    See ref 2** pg 10, eq (31)
    '''
    J = np.zeros((k,k))
    for i in range(k):
        J[k-i-1, i] = 1
    return J

def H_P(vxi1, vp1, vwe1, vxi2, vp2, vwe2):
    '''
    Calculate the full tensor-product extraction matrix 
    See ref 2** pg 12, eq (40)
    '''
    return np.kron(H_ext(vxi2, vp2, vwe2)[0],H_ext(vxi1, vp1, vwe1)[1])

def ME(vxi1, vp1, ns):
    '''
    Calculate second block of matrix E, i.e. J_{3}E_barJ_{8}
    See ref 2** pg 12, eq (41)
    '''
    # ns = len(vxi1)
    E = E_bar(vxi1, vp1, ns)
    return block_diag(E, anti_diagonal(3).dot(E.dot(anti_diagonal(2*ns))))

def HE(vxi1, vp1, vwe1, vxi2, vp2, vwe2, ns):
    '''
    Calculate the product of EH
    See ref 2** pg 12
    '''
    # ns, nt = H(vxi1, vp1, vwe1)[1].shape
    HM = H_P(vxi1, vp1, vwe1, vxi2, vp2, vwe2)
    E = ME(vxi1, vp1, ns)
    return E.dot(HM)

def M_b_pol_sp(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2):
    Ms, cs = get_matrix_b_mu(vp1, vxi1, tau_1, vwe1, lt1)
    Mt, ct = get_matrix_b_mu(vp2, vxi2, tau_2, vwe2, lt2)
    rMs, cMs = Ms.shape
    rMt, cMt = Mt.shape
    M = []
    for s in range(cMs):
        for t in range(cMt):
            b = np.zeros(rMs*rMt)
            for j in range(rMt):
                for i in range(rMs):
                    b[(i)+j*rMs] = Ms[i,s]*Mt[j,t]
            M.append(b)
    M = np.array(M)
    return M.T

def check_col(M):
    r,c = M.shape
    for j in range(c):
        for i in range(r):
            if (M[i,j] != 0):
                print(M[i,j])
    return True

# def plot_t(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2, ax, ay, az):
#     f1 = np.array([0, 2*np.sqrt(2)*ay, az])
#     f2 = np.array([-np.sqrt(6)*ax, -np.sqrt(2)*ay, az])
#     f3 = np.array([np.sqrt(6)*ax, -np.sqrt(2)*ay, az])
#     f4 = np.array([-np.sqrt(6)*ax, -np.sqrt(2)*ay, -az])
#     f5 = np.array([np.sqrt(2)*ax, -np.sqrt(2)*ay, -az])
#     f6 = np.array([0, 2*np.sqrt(2)*ay, -az])
#     vf = [f1, f2, f3, f4, f5, f6]
#     Mb = M_b_pol_sp(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2)
#     # print(Mb)
#     # print(Mb.shape)
#     H = H_P(vxi1, vp1, vwe1, vxi2, vp2, vwe2)
#     # print(H)
#     # print(H.shape)
#     E = ME(vxi1, vp1)
#     # print(E)
#     # print(E.shape)
#     rE, cE = E.shape
#     rH, cH = H.shape
#     rMb, cMb = Mb.shape
#     xcp = []
#     ycp = []
#     zcp = []
#     for st in range(cMb):
#         f = np.zeros(3)
#         for l in range(rE):
#             sE = 0
#             for j in range(cE):
#                 sHb = 0
#                 for k in range(cH):
#                     sHb = sHb + H[j,k]*Mb[k,st]
#                 sE = sE + sHb*E[l,j]
#             f = f + vf[l]*sE
#         xcp.append(f[0])
#         ycp.append(f[1])
#         zcp.append(f[2])
#         # print(f,l)
#     fig = plt.figure()
#     ax = fig.add_subplot(111, projection='3d')
#     ax.scatter(xcp,ycp,zcp)
#     plt.show()
def plot_t(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2, ax, ay, az, Mf):
    '''
    Calculate ellipsoids (and as a special case also spheres) built using the C1 polar spline
    Plot of arbitrary ellipsoids using smooth polar splines.
    See ref 2** pg 12, eq (40)
    ''' 
    Mb = M_b_pol_sp(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2)
    H = H_P(vxi1, vp1, vwe1, vxi2, vp2, vwe2)
    Haux = H_ext(vxi1, vp1, vwe1)[1]
    ns, cH = Haux.shape
    E = ME(vxi1, vp1, ns)
    rMb, cMb = Mb.shape
    xcp = []
    ycp = []
    zcp = []
    xc = [Mf[i][0] for i in range(3)]
    yc = [Mf[i][1] for i in range(3)]
    zc = [Mf[i][2] for i in range(3)]
    xc1 = [Mf[i][0] for i in range(3,6)]
    yc1 = [Mf[i][1] for i in range(3,6)]
    zc1 = [Mf[i][2] for i in range(3,6)]
    xc.append(Mf[0][0])
    yc.append(Mf[0][1])
    zc.append(Mf[0][2])
    xc1.append(Mf[3][0])
    yc1.append(Mf[3][1])
    zc1.append(Mf[3][2])
    for st in range(cMb):
        f = (Mf.T).dot(E.dot(H.dot(Mb[:,st])))
        xcp.append(f[0])
        ycp.append(f[1])
        zcp.append(f[2])
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(xcp,ycp,zcp)
    ax.scatter(xc,yc,zc)
    ax.scatter(xc1,yc1,zc1)
    plt.plot(xc, yc, zc)
    plt.plot(xc1, yc1, zc1)
    plt.show()    


vp1 = [2,2,2,2] 
vxi1 = [[0,0,0,1,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1]]
vwe1 = [[1,np.sqrt(2)/2,1],[1,np.sqrt(2)/2,1],[1,np.sqrt(2)/2,1],[1,np.sqrt(2)/2,1]]
tau_1 = 0
lt1 = lt2 = 20
vp2 = [2,2] 
vxi2 = [[0,0,0,1,1,1],[0,0,0,1,1,1]]
vwe2 = [[1,np.sqrt(2)/2,1],[1,np.sqrt(2)/2,1]]
tau_2 = 0
ax = 1
ay = 1/2
az = 1/3
Mf = np.array([[0, 2*np.sqrt(2)*ay, az], \
               [-np.sqrt(6)*ax, -np.sqrt(2)*ay, az],\
               [np.sqrt(6)*ax, -np.sqrt(2)*ay, az],\
               [-np.sqrt(6)*ax, -np.sqrt(2)*ay, -az],\
               [np.sqrt(2)*ax, -np.sqrt(2)*ay, -az], \
               [0, 2*np.sqrt(2)*ay, -az]]) 
plot_t(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2, ax, ay, az, Mf)
