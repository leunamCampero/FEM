


from scipy.interpolate import griddata
from mpl_toolkits import mplot3d
from matplotlib import cm
import matplotlib.pyplot as plt
import numpy as np
import scipy.integrate as integrate
import scipy.special
from scipy.linalg import block_diag
# from math import isclose


def nf(r, p, m):
    '''
    Compute dimension of S_{r}^{p}(Delta) 
    Read Book**1 pg 5, Proposition 2.6
    '''
    psi = sum((r[i] + 1) for i in range(1, m))
    theta = sum((p[i] + 1) for i in range(m))
    return theta - psi

    
def inv_f(x, x_i_1, x_i):
    assert x_i - x_i_1 > 0, '[x_i_1, x_i] is not an interval'
    return (x-x_i)/(x_i-x_i_1) + 1
    # return (x-x_i_1)/(x_i-x_i_1)
        
def G_B_S_Trig(xh, q, j, x_i_1, x_i, w):
    '''
    The generalized Bernstein basis for the trigonometric 
    space defined on [0, 1], see Book**1 pg 20 Example 7.6.
    '''
    assert q > 0, 'q have to be greater than 0, See Book**1 pg 20'
    x = inv_f(xh, x_i_1, x_i)
    w = w*(x_i-x_i_1)
    # x = xh
    if (q == 1):
        if (j == 0):
            return np.sin(w*(1-x))/np.sin(w)
        else:
            return np.sin(w*x)/np.sin(w)
    elif (q == 2):
        if (j == 0):
            return (1-np.cos(w*(1-x)))/(1-np.cos(w))
        elif (j == 1):
            return (np.cos(w*(1-x))+np.cos(w*x)-np.cos(w)-1)/(1-np.cos(w))
        else:
            return (1-np.cos(w*x))/(1-np.cos(w))
    else:
        if (j == 0):
            b_0_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, 0, 0, 1, w), 0, 1)[0]
            return 1 - integrate.quad(lambda y: (1/b_0_q_1)*G_B_S_Trig(y, q-1, 0, 0, 1, w), 0, x)[0]
        elif (0 < j < q) and (q > 1):
            b_j_1_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, j-1, 0, 1, w), 0, 1)[0]
            b_j_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, j, 0, 1, w), 0, 1)[0]
            s1 = integrate.quad(lambda y: (1/b_j_1_q_1)*G_B_S_Trig(y, q-1, j-1, 0, 1, w), 0, x)[0]
            s2 = integrate.quad(lambda y: (1/b_j_q_1)*G_B_S_Trig(y, q-1, j, 0, 1, w), 0, x)[0]
            return s1 - s2
        else:
            b_q_1_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, q-1, 0, 1, w), 0, 1)[0]
            return integrate.quad(lambda y: (1/b_q_1_q_1)*G_B_S_Trig(y, q-1, q-1, 0, 1, w), 0, x)[0]
        
        
def k_th_diff_G_B_S(k, xh, q, j, x_i_1, x_i, w):
    '''
    The generalized Bernstein basis for the trigonometric 
    space defined on [0, 1], see Book**1 pg 20 Example 7.6.
    '''
    assert q > 0, 'q have to be greater than 0, See Book**1 pg 20'
    if (k == 0):
        return G_B_S_Trig(xh, q, j, x_i_1, x_i, w)
    if (k > 0):
        x = inv_f(xh, x_i_1, x_i)
        dx = 1/(x_i - x_i_1)
        w = w*(x_i-x_i_1)
        if (q == 1):
            if (k == 1):
                if (j == 0):
                    return -dx*np.cos(w*(1-x))*w/np.sin(w)
                else:
                    return dx*np.cos(w*x)*w/np.sin(w)
            else:
                if (j == 0):
                    return -dx*np.sin(w*(1-x))*(w**2)/np.sin(w)
                else:
                    return -dx*np.sin(w*x)*(w**2)/np.sin(w)        
        elif (q == 2):
            if (k == 1):
                if (j == 0):
                    return -dx*np.sin(w*(1-x))*w/(1-np.cos(w))
                elif (j == 1):
                    return dx*w*(np.sin(w*(1-x))-np.sin(w*x))/(1-np.cos(w))
                else:
                    return  dx*np.sin(w*x)*w/(1-np.cos(w))
            else:
                if (j == 0):
                    return np.cos(w*(1-x))*((dx*w)**2)/(1-np.cos(w))
                elif (j == 1):
                    return (dx*w)**2*(-np.cos(w*(1-x))-np.cos(w*x))/(1-np.cos(w))
                else:
                    return np.cos(w*x)*((dx*w)**2)/(1-np.cos(w))    
        else:
            if (j == 0):
                b_0_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, 0, 0, 1, w), 0, 1)[0]
                return -dx*(1/b_0_q_1)*k_th_diff_G_B_S(k-1, x, q-1, 0, 0, 1, w)
            elif (0 < j < q) and (q > 1):
                b_j_1_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, j-1, 0, 1, w),0, 1)[0]
                b_j_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, j, 0, 1, w), 0, 1)[0]
                s1 = dx*(1/b_j_1_q_1)*k_th_diff_G_B_S(k-1, x, q-1, j-1,  0, 1, w)
                s2 = dx*(1/b_j_q_1)*k_th_diff_G_B_S(k-1, x, q-1, j,  0, 1, w)
                return s1 - s2
            else:
                b_q_1_q_1 = integrate.quad(lambda y: G_B_S_Trig(y, q-1, q-1, 0, 1, w), 0, 1)[0]
                return dx*(1/b_q_1_q_1)*k_th_diff_G_B_S(k-1, x, q-1, q-1,  0, 1, w)
      
def bin_(n, k):
    '''
    Function to compute the binomial coefficient times (-1)^{k+n}
    See Function k_th_diff_G_B_S
    '''
    return ((-1)**(k+n))*scipy.special.binom(n, k)
        
def jump_xi_k(k, x, q, j, x_i_1, x_i, w):
    eps = 1e-7
    left_D = 0
    right_D = 0
    if (x_i_1 <= x - eps <= x_i):
        left_D = k_th_diff_G_B_S(k, x, q, j, x_i_1, x_i, w)
    if (x_i_1 <= x + eps <= x_i):
        right_D = k_th_diff_G_B_S(k, x, q, j, x_i_1, x_i, w)
    return left_D - right_D

def plot_algebraic_B_Spline(p, x_i_1, x_i, w, lt):
    assert p > 0, 'p have to be greater than 0, See Book**1 pg 20'
    xc = np.linspace(x_i_1, x_i, lt, endpoint=True)
    for q in range(p+1):
        yc = []
        for i in range(len(xc)):
            yc.append(G_B_S_Trig(xc[i], p, q, x_i_1, x_i, w))
        plt.plot(xc, yc)
    return plt.show()

def phi_i(x, x1, x2, i, tau_1):
    '''
    See ref**2 pg 4, eq (5)
    '''
    return x-x1[i]+tau_1+sum(x2[j]-x1[j] for j in range(i))
    
def get_n(vxi, vp):
    '''
    Function to obtain m^{i} = len(xi)-p^{i}-1 when we are considering Rational
    multi-degree B-splines
    '''
    return [len(vxi[i])-vp[i]-1 for i in range(len(vp))]

def mu_i(vn, i):
    '''
    Function to obtain the cumulative local dimension
    See ref**2 pg 4
    '''
    return 0 if i == 0 else sum(vn[j] for j in range(i))

def get_tau(x1, x2, tau_1):
    '''
    Function to compute phi^{i}(x_{1}^{i}) and phi^{i}(x_{2}^{i}) for i=1,...,m.
    See ref**2 pg 5, eq (7), (8) and (9)
    '''
    vtau_1 = [phi_i(x1[i], x1, x2, i, tau_1) for i in range(len(x1))]
    vtau_2 = [phi_i(x2[i], x1, x2, i, tau_1) for i in range(len(x2))]
    return vtau_1, vtau_2

def s_b_mu(x, p, x_i_1, x_i, w, q):
    '''
    Function to compute B_{j}^{i} in the definition of the global Bernstein basis
    See ref**2 pg 12, Definition 4.3
    '''
    if (x_i_1 <= x <= x_i):
        return G_B_S_Trig(x, p, q, x_i_1, x_i, w)
    else:
        return 0

def D_s_b_mu(k, x, p, x_i_1, x_i, w, q):
    '''
    Function to compute one element in the column vector A_{rho}(A) 
    in the Theorem of Bezier Extraction
    See ref**2 pg 17, Theorem 6.2
    '''
    if (x_i_1 <= x <= x_i):
        return k_th_diff_G_B_S(k, x, p, q, x_i_1, x_i, w)
    else:
        return 0

def s_b_mu_d(k, x, p, x_i_1, x_i, w, q):
    '''
    Function to compute B_{j}^{i} in the definition of the global Bernstein basis
    See ref**2 pg 12, Definition 4.3
    '''
    if (x_i_1 <= x <= x_i):
        return k_th_diff_G_B_S(k, x, p, q, x_i_1, x_i, w)
    else:
        return 0
    
def get_matrix_b_mu(vp, Delta, tau_1, vw, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb
    '''
    m = len(vp)
    if (m > 1):
        x1 = [Delta[i] for i in range(len(Delta)-1)]
        x2 = [Delta[i] for i in range(1,len(Delta))]
        ct = []
        Mb = []
        for i in range(m):
            xc = np.linspace(x1[i], x2[i], lt, endpoint=False)
            for x in xc:
                ct.append(phi_i(x, x1, x2, i, tau_1))
        ct.append(phi_i(x2[m-1], x1, x2, m-1, tau_1))
        ct = np.array(ct)
        # print(ct)
        for i in range(m):
            for q in range(vp[i]+1):
                ptc = []
                te = []
                for k in range(m):
                    ptca = []
                    if (k == i):
                        xc = [r for r in ct if (r >= x1[k]) and (r < x2[k])]
                        # print(xc, 1)
                        # xc = ct[(ct >= x1[k]) and (ct <= x2[k])]
                        for x in xc:
                            te.append(x)
                            ptc.append(s_b_mu(x, vp[k], x1[k], x2[k], vw, q))
                            ptca.append(s_b_mu(x, vp[k], x1[k], x2[k], vw, q))
                        # print(ptca)
                    # elif (k == i+1):
                        # xc = [r for r in ct if (r > x1[k]) and (r < x2[k])]
                        # print(xc, 2)
                        # xc = ct[(ct > x1[k]) and (ct < x2[k])]
                        # for x in xc:
                            # te.append(x)
                            # ptc.append(0)
                            # ptca.append(0)
                        # print(ptca)
                    else: 
                        xc = [r for r in ct if (r >= x1[k]) and (r < x2[k])]
                        # print(xc, 3)
                        # xc = ct[(ct >= x1[k]) and (ct < x2[k])]
                        for x in xc:
                            te.append(x)
                            ptc.append(0)
                            ptca.append(0)
                        # print(ptca)
                if (i != m-1):
                    ptc.append(0)
                    te.append(x2[m-1])
                else:
                    ptc.append(s_b_mu(x2[m-1], vp[m-1], x1[m-1], x2[m-1], vw, q))
                # print(te, q, 'Fc')
                # print(ptc, q, 'Fc')
                # print(ptc)
                # print(te1)
                # print(ct)
                Mb.append(ptc)
            # print('Hello')
        # print(Mb, ct)
        return np.array(Mb), ct
    elif (m == 1):
        ct = np.linspace(Delta[0], Delta[1], lt, endpoint=True)
        Mb = []
        for q in range(vp[0]+1):
            ptc = []
            for i in range(len(ct)):
                ptc.append(G_B_S_Trig(ct[i], vp[0], q, Delta[0], Delta[1], vw))
            Mb.append(ptc)
        return np.array(Mb), ct

def leggauss_ab(n, a, b):
    assert(n >0)
    x,w = np.polynomial.legendre.leggauss(n)
    x = (b-a)*0.5*x+(b+a)*0.5
    w = w*(b-a)*0.5
    return x,w
    
def get_matrix_b_mu_qp(vp, Delta, tau_1, vw, lt, num_q):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb
    '''
    m = len(vp)
    if (m > 1):
        x1 = [Delta[i] for i in range(len(Delta)-1)]
        x2 = [Delta[i] for i in range(1,len(Delta))]
        ct, weights  = leggauss_ab(num_q, min(x1), max(x2))
        Mb = []
        # print(ct)
        for i in range(m):
            for q in range(vp[i]+1):
                ptc = []
                te = []
                for k in range(m):
                    ptca = []
                    if (k == i):
                        xc = [r for r in ct if (r >= x1[k]) and (r < x2[k])]
                        for x in xc:
                            te.append(x)
                            ptc.append(s_b_mu(x, vp[k], x1[k], x2[k], vw, q))
                            ptca.append(s_b_mu(x, vp[k], x1[k], x2[k], vw, q))
                    else: 
                        xc = [r for r in ct if (r >= x1[k]) and (r < x2[k])]
                        for x in xc:
                            te.append(x)
                            ptc.append(0)
                            ptca.append(0)
                        # print(ptca)
                if (len(ct) != len(ptc)):
                    ptc.append(s_b_mu(ct[len(ct)-1], vp[m-1], x1[m-1], x2[m-1], vw, q))
                    te.append(x2[m-1])
                # print(te, q, 'Fc')
                # print(ptc, q, 'Fc')
                # print(ptc)
                # print(te1)
                # print(ct)
                Mb.append(ptc)
            # print('Hello')
        # print(Mb, ct)
        return np.array(Mb), ct, weights
    

def get_matrix_b_mu_d(kk, vp, Delta, tau_1, vw, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x})
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which
    the same number of elements than a row of the matrix Mb
    '''
    m = len(vp)
    assert m > 1, 'Use plot_algebraic_B_Spline for a partition without breakpoints'
    x1 = [Delta[i] for i in range(len(Delta)-1)]
    x2 = [Delta[i] for i in range(1,len(Delta))]
    ct = []
    Mb = []
    for i in range(m):
        xc = np.linspace(x1[i], x2[i], lt, endpoint=True)
        for x in xc:
            ct.append(phi_i(x, x1, x2, i, tau_1))
    for i in range(m):
        for q in range(vp[i]+1):
            ptc = []
            for k in range(m):
                xc = np.linspace(x1[k], x2[k], lt, endpoint=True)
                #print(x1[k], x2[k])
                if (k == i):
                    for x in xc:
                        ptc.append(s_b_mu_d(kk, x, vp[k], x1[k], x2[k], vw, q))
                else:
                    for x in xc:
                        ptc.append(0)
            Mb.append(ptc)
    return np.array(Mb), ct

def plot_b_mu(vp, Delta, tau_1, vw, lt):
    Bb, ct = get_matrix_b_mu(vp, Delta, tau_1, vw, lt)
    nr, nc = Bb.shape
    for i in range(nr):
        plt.plot(ct, Bb[i,:])
    plt.show()
    
def plot_b_mu_q_p(vp, Delta, tau_1, vw, lt, num_q):
    Bb, ct, weights = get_matrix_b_mu_qp(vp, Delta, tau_1, vw, lt, num_q)
    nr, nc = Bb.shape
    for i in range(nr):
        plt.plot(ct, Bb[i,:])
    plt.show()
    
def plott_b_mu_d(k, vp, Delta, tau_1, vw, lt):
    Bb, ct = get_matrix_b_mu_d(k, vp, Delta, tau_1, vw, lt)
    nr, nc = Bb.shape
    for i in range(nr):
        plt.plot(ct, Bb[i,:])
    plt.show()
    
def get_m_qp(vp, Delta, tau_1, vw, lt, r, num_q):
    '''
    Function that plot the GTB-spline basis.
    '''
    A_r = A_rho_B(vp, r, vw, Delta)
    A_rp = A_rho_BPS(vp, r, vw, Delta)
    Cper = extraction_mat_ps(A_r, A_rp, len(vp), r[0], r)
    Bb, ct, weights = get_matrix_b_mu_qp(vp, Delta, tau_1, vw, lt, num_q)
    N = Cper.dot(Bb)
    nr, nc = N.shape
    for i in range(nr):
        plt.plot(ct, N[i,:])
    plt.show()
    return N, ct, weights

def L2_inner_p(N1, N2, weights):
    s = 0
    for i in range(N1.shape[0]):
        s = s + weights[i]*N1[i]*N2[i]
    return s

def L2_inner_p_v(N1, f, ct, weights):
    s = 0
    for i in range(N1.shape[0]):
        s = s + weights[i]*N1[i]*f(ct[i])
    return s
    


def L2_projection(vp, Delta, tau_1, vw, lt, r, num_q, my_f):
    N, ct, weights = get_m_qp(vp, Delta, tau_1, vw, lt, r, num_q)
    nr, nc = N.shape
    A = np.zeros((nr,nr))
    v = np.zeros((nr, 1))
    for i in range(nr):
        for j in range(nr):
            A[i,j] = L2_inner_p(N[i,:], N[j,:], weights)
        v[i] = L2_inner_p_v(N[i,:], my_f, ct, weights)
    Ainv = np.linalg.pinv(A)
    error = L2_innerp_error(Ainv.dot(v), v, weights)
    print(my_f, error)
    return Ainv.dot(v)

def plott_CB(vp, Delta, tau_1, vw, lt, r):
    '''
    Function that plot the GTB-spline basis.
    '''
    A_r = A_rho_B(vp, r, vw, Delta)
    # C = Extraction_Operator(A_r)
    C = extraction_mat(A_r, len(vp), r)
    Bb, ct = get_matrix_b_mu(vp, Delta, tau_1, vw, lt)
    N = C.dot(Bb)
    nr, nc = N.shape
    for i in range(nr):
        plt.plot(ct, N[i,:])
    plt.show()

def plot_s_b_mu(kk, vp, Delta, tau_1, vw, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb, and plot it.
    '''
    m = len(vp)
    assert m > 1, 'Use plot_algebraic_B_Spline for a partition without breakpoints'
    x1 = [Delta[i] for i in range(len(Delta)-1)]
    x2 = [Delta[i] for i in range(1,len(Delta))]
    vtau_1, vtau_2 = get_tau(x1, x2, tau_1)
    ct = []
    for i in range(m):
        xc = np.linspace(x1[i], x2[i], lt, endpoint=True)
        for x in xc:
            ct.append(phi_i(x, x1, x2, i, tau_1))
    for i in range(m):
        for q in range(vp[i]+1):
            ptc = []
            for k in range(m):
                xc = np.linspace(x1[k], x2[k], lt, endpoint=True)
                if (k == i):
                    for x in xc:
                        ptc.append(s_b_mu(x, vp[k], x1[k], x2[k], vw, q))
                else: 
                    for x in xc:
                        ptc.append(0)
            plt.plot(ct, ptc)
    plt.show()    

def plot_D_s_b_mu(kk, vp, Delta, tau_1, vw, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb, and plot it.
    '''
    m = len(vp)
    assert m > 1, 'Use plot_algebraic_B_Spline for a partition without breakpoints'
    x1 = [Delta[i] for i in range(len(Delta)-1)]
    x2 = [Delta[i] for i in range(1,len(Delta))]
    vtau_1, vtau_2 = get_tau(x1, x2, tau_1)
    ct = []
    for i in range(m):
        xc = np.linspace(x1[i], x2[i], lt, endpoint=True)
        for x in xc:
            ct.append(phi_i(x, x1, x2, i, tau_1))
    for i in range(m):
        for q in range(vp[i]+1):
            ptc = []
            for k in range(m):
                xc = np.linspace(x1[k], x2[k], lt, endpoint=True)
                if (k == i):
                    for x in xc:
                        ptc.append(D_s_b_mu(kk, x, vp[k], x1[k], x2[k], vw, q))
                else: 
                    for x in xc:
                        ptc.append(0)
            plt.plot(ct, ptc)
    plt.show() 
    
def get_matrix_D_s_b_mu(kk, vp, Delta, tau_1, vw, lt):
    '''
    Generate a Matrix in whic every row is b_{\mu_{i-1}+j}(phi_{x}) 
    evaluate in [x1[0],x2[m-1]]. Also return the vector [t1,t2] which 
    the same number of elements than a row of the matrix Mb, and plot it.
    '''
    m = len(vp)
    assert m > 1, 'Use plot_algebraic_B_Spline for a partition without breakpoints'
    x1 = [Delta[i] for i in range(len(Delta)-1)]
    x2 = [Delta[i] for i in range(1,len(Delta))]
    vtau_1, vtau_2 = get_tau(x1, x2, tau_1)
    ct = []
    Mb = []
    for i in range(m):
        xc = np.linspace(x1[i], x2[i], lt, endpoint=True)
        for x in xc:
            ct.append(phi_i(x, x1, x2, i, tau_1))
    for i in range(m):
        for q in range(vp[i]+1):
            ptc = []
            for k in range(m):
                xc = np.linspace(x1[k], x2[k], lt, endpoint=True)
                if (k == i):
                    for x in xc:
                        ptc.append(D_s_b_mu(kk, x, vp[k], x1[k], x2[k], vw, q))
                else: 
                    for x in xc:
                        ptc.append(0)
            Mb.append(ptc)
    return np.array(Mb), ct   

def plott_C_DB(kk, vp, Delta, tau_1, vw, lt, r):
    '''
    Function that plot the GTB-spline basis.
    '''
    A_r = A_rho_B(vp, r, vw, Delta)
    C = Extraction_Operator(A_r)
    # C = M_almost_zero(C1) 
    Bb, ct = get_matrix_D_s_b_mu(kk, vp, Delta, tau_1, vw, lt)
    N = C.dot(Bb)
    nr, nc = N.shape
    for i in range(nr):
        plt.plot(ct, N[i,:])
    plt.show()
    
def nullspace(a):
    '''
    Nullspace computation of a smoothness constraint based on knot insertion, 
    see Book**1 Algorithm 6.1.
    '''
    n = len(a)
    C_tilde = np.zeros((n-1,n), dtype = np.float64)
    k = 0
    while (k < (n - 1)) and (abs(a[k]) == 0):
        C_tilde[k,k] = 1
        k = k + 1
    C_tilde[k,k] = 1
    while ((k + 1) < (n-1)) and (abs(a[k + 1]) != 0):
        C_tilde[k, k + 1] = -C_tilde[k,k]*a[k]/a[k+1]
        C_tilde[k + 1, k + 1] = 1 - C_tilde[k, k + 1]
        k = k + 1
    while (k < (n - 1)):
        C_tilde[k, k + 1] = 1
        k = k + 1
    return C_tilde

def CA_rho_B(x, vp, i_B, j_B, Delta, w, r):
    '''
    Function to build one column of the input matrix for the Generalized Bezier extraction
    See ref**1, pg 17, Theorem 6.2
    '''
    m = len(vp)
    theta = sum((vp[i] + 1) for i in range(m))
    B = np.zeros(theta)
    if (i_B < m):
        x_i_1 = Delta[i_B]
        x_i = Delta[i_B+1]
        x_l_1 = Delta[i_B-1]
        for i in range(m):
            c = 0
            for q in range(vp[i]+1):
                ind = sum((vp[k] + 1) for k in range(i)) + q 
                if (i == i_B): 
                    if (c < j_B + 1):
                        B[ind] = jump_xi_k(j_B, x, vp[i], q, x_i_1, x_i, w)
                        c = c + 1
                    else:
                        B[ind] = 0
                elif (i == i_B-1):
                    if (c < vp[i]-j_B):
                        B[ind] = 0
                        c = c + 1
                    else:
                        B[ind] = jump_xi_k(j_B, x, vp[i], q, x_l_1, x_i_1, w)
                else:
                    B[ind] = 0
        return B

def CA_rho_BPS(x, vp, i_B, j_B, Delta, w, r):
    m = len(vp)
    theta = sum((vp[i] + 1) for i in range(m))
    B = np.zeros(theta)
    av = [0, m-1]
    for i in av:
        if(i == 0):
            c = 0
            for q in range(vp[i]+1):
                ind = sum((vp[k] + 1) for k in range(i)) + q 
                if (c < j_B + 1):
                    B[ind] = -k_th_diff_G_B_S(j_B, Delta[0], vp[i], q, Delta[0], Delta[1], w)
                    c = c + 1
                else:
                    B[ind] = 0
        else:
            c = 0
            for q in range(vp[i]+1):
                ind = sum((vp[k] + 1) for k in range(i)) + q 
                if (c < vp[i]-j_B):
                    B[ind] = 0
                    c = c + 1
                else:
                    B[ind] = k_th_diff_G_B_S(j_B, Delta[m], vp[i], q, Delta[m-1], Delta[m], w)
    return B

def A_rho_B(vp, r, w, Delta):
    '''
    Function to build the input matrix for the Generalized Bezier extraction
    See ref**1, pg 17, Theorem 6.2
    '''
    m = len(vp)
    A_r = []
    for i_B in range(1,m):
        MP = []
        for j_B in range(r[i_B] + 1):
            MP.append(CA_rho_B(Delta[i_B], vp, i_B, j_B, Delta, w, r))
        A_r.append(np.array(MP).T)
    return A_r


def A_rho_BPS(vp, r, w, Delta):
    '''
    Function to build the input matrix for the Generalized Bezier extraction
    See ref**1, pg 17, Theorem 6.2
    '''
    m = len(vp)
    A_r = []
    i_B = m 
    for j_B in range(r[0] + 1):
        A_r.append(CA_rho_BPS(Delta[i_B], vp, i_B, j_B, Delta, w, r[0]))
    return np.array(A_r).T

def Extraction_Operator(A_r):
    '''
    Function to calculate Generalized Bezier extraction
    See ref**1, pg 18, Algorithm 6.2
    '''
    rAr, cAr = A_r.shape
    C = np.eye(rAr)
    for rho in range(cAr):
        C_tilde = nullspace(A_r[:,rho])
        C = C_tilde.dot(C)
        A_r = C_tilde.dot(A_r)
    return C

def extraction_mat(A_r, ns, r):
    rAr, cAr = A_r[0].shape
    H = np.eye(rAr)
    for i in range(1,ns):
        L = H.dot(A_r[i-1])
        for j in range(r[i]+1):
            H_bar = nullspace(L[:,j])
            H = H_bar.dot(H)
            L = H_bar.dot(L)
    return H

def extraction_mat_ps(A_r, A_rp, ns, rps, r):
    C = extraction_mat(A_r, ns, r)
    Hper = circshift(C, rps+1)
    Lper = Hper.dot(A_rp)
    for j in range(rps+1):
        H_bar = nullspace(Lper[:,j])
        Hper = H_bar.dot(Hper)
        Lper = H_bar.dot(Lper)
    return Hper

def circshift(H, r):
    nr, nc = H.shape
    M = np.zeros((nr,nc))
    for i in range(nr):
        M[(i+r) % nr,:] = H[i, :]
    return M

def plott_CBPS(vp, Delta, tau_1, vw, lt, r):
    '''
    Function that plot the GTB-spline basis.
    '''
    A_r = A_rho_B(vp, r, vw, Delta)
    A_rp = A_rho_BPS(vp, r, vw, Delta)
    Cper = extraction_mat_ps(A_r, A_rp, len(vp), r[0], r)
    Bb, ct = get_matrix_b_mu(vp, Delta, tau_1, vw, lt)
    N = Cper.dot(Bb)
    # print(N)
    nr, nc = N.shape
    for i in range(nr):
        plt.plot(ct, N[i,:])
    plt.show()

def ext_spline(M, v, vs, lt):
    nr, nc = M.shape
    ls = 4-len(vs)
    A = np.zeros((nr, lt*ls + 1))
    a = np.zeros(lt*ls + 1)
    c = 0
    c1 = 0
    c2 = 0
    for j in range(nc):
        if not ((vs[c2]) <= v[j] < (vs[c2]+1)):
            A[:,c] = M[:,j]
            a[c] = v[j]
            c = c + 1
        c1 = c1 + 1
        if (c1 % lt == 0):
            c1 = 0
        if (c1 == 0 and c2 < len(vs)-1):
            c2 = c2 + 1
    return A,a
    
def ctr_ptM(MB, ct, lt):
    nr, nc = MB.shape
    # ju = (nc-1)/lt
    A = MB[:,0].T
    c = 0
    for i in range(len(ct)):
        if ct[i] <= 2*np.pi:
            c = c + 1
    vcos = np.zeros((c, 1))
    vsin = np.zeros((c, 1))
    vcos[0,0] = np.cos(ct[0])
    vsin[0,0] = np.sin(ct[0])
    for i in range(1,c):
        A = np.concatenate((A, MB[:,i]), axis=0)
        vcos[i,0] = np.cos(ct[i])
        vsin[i,0] = np.sin(ct[i])
    # Ainv = np.linalg.inv(A.reshape(nr, nc))
    A = A.reshape(c, nr)
    # Ainv = np.linalg.pinv(A)
    
    ATA = A.T.dot(A)
    Ainv = np.linalg.pinv(ATA).dot(A.T)
    # print(np.linalg.cond(ATA))
    
    # res1 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vcos))
    # res2 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vsin))
    # print(np.linalg.cond(Ainv))
    return Ainv.dot(vcos), Ainv.dot(vsin) 

def ctr_ptM3(MB, ct, lt, vw):
    # sx = 2*np.pi/(ct[len(ct)-1])
    nr, nc = MB.shape
    # ju = (nc-1)/lt
    A = MB[:,0].T
    vcos = np.zeros((nc, 1))
    vsin = np.zeros((nc, 1))
    vcos[0,0] = np.cos(ct[0])
    vsin[0,0] = np.sin(ct[0])
    for i in range(1,nc):
        A = np.concatenate((A, MB[:,i]), axis=0)
        vcos[i,0] = np.cos(ct[i])
        vsin[i,0] = np.sin(ct[i])
    # Ainv = np.linalg.inv(A.reshape(nr, nc))
    A = A.reshape(nc, nr)
    # Ainv = np.linalg.pinv(A)
    
    ATA = A.T.dot(A)
    Ainv = np.linalg.pinv(ATA).dot(A.T)
    # print(np.linalg.cond(ATA))
    
    # res1 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vcos))
    # res2 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vsin))
    # print(np.linalg.cond(Ainv))
    return Ainv.dot(vcos), Ainv.dot(vsin) 


def ctr_ptM2(MB, ct, lt):
    nr, nc = MB.shape
    # ju = (nc-1)/lt
    A = MB[:,0].T
    vcos = np.zeros((nr, 1))
    vsin = np.zeros((nr, 1))
    vcos[0,0] = np.cos(ct[0])
    vsin[0,0] = np.sin(ct[0])
    values = []
    for i in range(1,nr):
        A = np.concatenate((A, MB[:,i*lt]), axis=0)
        vcos[i,0] = np.cos(ct[i*lt])
        vsin[i,0] = np.sin(ct[i*lt])
        values.append(ct[i*lt])
    # Ainv = np.linalg.inv(A.reshape(nr, nc))
    A = A.reshape(nr, nr)
    # Ainv = np.linalg.pinv(A)
    
    Ainv = np.linalg.pinv(A)
    # print(np.linalg.cond(ATA))
    
    # res1 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vcos))
    # res2 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vsin))
    # print(np.linalg.cond(Ainv))
    return Ainv.dot(vcos), Ainv.dot(vsin) 

def ctr_ptM1(MB, ct, lt):
    nr, nc = MB.shape
    # ju = (nc-1)/lt
    A = MB[:,0].T
    vcos = np.zeros((nr, 1))
    vsin = np.zeros((nr, 1))
    vcos[0,0] = np.cos(ct[0])
    vsin[0,0] = np.sin(ct[0])
    for i in range(1,nr):
        A = np.concatenate((A, MB[:,i]), axis=0)
        vcos[i,0] = np.cos(ct[i])
        vsin[i,0] = np.sin(ct[i])
    # Ainv = np.linalg.inv(A.reshape(nr, nc))
    A = A.reshape(nr, nr)
    Ainv = np.linalg.pinv(A)
    # ATA = A.reshape(nc,nr).T.dot( A.reshape(nc,nr))
    # print(np.linalg.cond(ATA))
    
    # res1 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vcos))
    # res2 =  np.linalg.inv(ATA) .dot( A.reshape(nc,nr).T.dot(vsin))
    # print(np.linalg.cond(Ainv))
    return Ainv.dot(vcos), Ainv.dot(vsin) 
    # return res1, res2
    
def plot_ellipse(vp, Delta, tau_1, lt, vw, r, vs):
    '''
    Plot circles and ellipses using C^{1} rational splines
    See ref**2, pg 6, subsection 2.4
    '''
    A_r = A_rho_B(vp, r, vw, Delta)
    A_rp = A_rho_BPS(vp, r, vw, Delta)
    Haux = extraction_mat_ps(A_r, A_rp, len(vp), r[0], r) 
    Mb, ct = get_matrix_b_mu(vp, Delta, tau_1, vw, lt)
    # print(ct)
    # MA, va = ext_spline(Mb, ct, vs, lt)
    # Mb = MA
    # ct = va
    MB = np.array(Haux).dot(Mb)
    res1, res2 = ctr_ptM3(MB, ct, lt, vw)
    nr, nc = MB.shape
    rp = ctrl_pts(nr)
    rp = ctrl_pts(nr)
    xcp = []
    ycp = []
    xc = [rp[i][0] for i in range(nr)]
    yc = [rp[i][1] for i in range(nr)]
    xcf = [res1[i][0] for i in range(nr)]
    ycf = [res2[i][0] for i in range(nr)]
    xc.append(rp[0][0])
    yc.append(rp[0][1])
    xcf.append(res1[0][0])
    ycf.append(res2[0][0])
    for i in range(nc):
        ft = np.array([0,0])
        for j in range(nr):
            ft = ft + np.array([res1[j,0], res2[j,0]])*MB[j,i]
            # ft = ft + rp[j]*MB[j,i]
        xcp.append(ft[0])
        ycp.append(ft[1])
    tcos = []
    tsin = []
    tcs = np.linspace(0, 2*np.pi, 100)
    for i in tcs:
        tcos.append(np.cos(i))
        tsin.append(np.sin(i))
    plt.plot(tcos, tsin)
    plt.plot(xcp, ycp)
    plt.plot(xc, yc)
    plt.scatter(xc, yc)
    plt.plot(xcf, ycf)
    plt.scatter(xcf, ycf)
    return plt.show()

def plot_ellipse_qp(vp, Delta, tau_1, lt, vw, r, vs, num_q):
    '''
    Plot circles and ellipses using C^{1} rational splines
    See ref**2, pg 6, subsection 2.4
    '''
    A_r = A_rho_B(vp, r, vw, Delta)
    A_rp = A_rho_BPS(vp, r, vw, Delta)
    Haux = extraction_mat_ps(A_r, A_rp, len(vp), r[0], r) 
    Mb, ct = get_matrix_b_mu(vp, Delta, tau_1, vw, lt)
    # print(ct)
    # MA, va = ext_spline(Mb, ct, vs, lt)
    # Mb = MA
    # ct = va
    MB = np.array(Haux).dot(Mb)
    # res1, res2 = ctr_ptM3(MB, ct, lt, vw)
    res1 = L2_projection(vp, Delta, tau_1, vw, lt, r, num_q, np.cos)
    res2 = L2_projection(vp, Delta, tau_1, vw, lt, r, num_q, np.sin)
    nr, nc = MB.shape
    rp = ctrl_pts(nr)
    rp = ctrl_pts(nr)
    xcp = []
    ycp = []
    xc = [rp[i][0] for i in range(nr)]
    yc = [rp[i][1] for i in range(nr)]
    xcf = [res1[i][0] for i in range(nr)]
    ycf = [res2[i][0] for i in range(nr)]
    xc.append(rp[0][0])
    yc.append(rp[0][1])
    xcf.append(res1[0][0])
    ycf.append(res2[0][0])
    for i in range(nc):
        ft = np.array([0,0])
        for j in range(nr):
            # ft = ft + np.array([rp[j,i], res2[j,i]])*MB[j,i]
            ft = ft + np.array([res1[j,0], res2[j,0]])*MB[j,i]
            # ft = ft + rp[j]*MB[j,i]
        xcp.append(ft[0])
        ycp.append(ft[1])
    tcos = []
    tsin = []
    tcs = np.linspace(0, 2*np.pi, 100)
    for i in tcs:
        tcos.append(np.cos(i))
        tsin.append(np.sin(i))
    plt.plot(tcos, tsin)
    plt.plot(xcp, ycp)
    plt.plot(xc, yc)
    plt.scatter(xc, yc)
    plt.plot(xcf, ycf)
    plt.scatter(xcf, ycf)
    return plt.show()

def norm_v(v):
    return v[0]**2 + v[1]**2
            
def projection(C1, C2):
    uv = C2.dot(C1)
    return (uv/norm_v(C1))*C1

def straightline(C1, C2):
    xp1, yp1 = projection(C1, C2.T)
    if xp1-C2[0] == 0:
        return 0, -1, C1[0]
    else:
        m = (C2[1]-yp1)/(C2[0]-xp1)
        return 1, m, -C1[0]*m + C1[1]
def cont_pt(C1, C2, C3):
    y1, m1, b1 = straightline(C1, C2)
    y2, m2, b2 = straightline(C2, C3)
    A = np.array([[-m1, y1],[-m2, y2]])
    return np.linalg.inv(A).dot(np.array([[b1],[b2]]))
  
def circ_pts(n):
    assert n > 1, 'n has to be greater or equal to 2'
    v = []
    for i in range(n):
        v.append(np.array([np.cos(np.radians(360-i*(360/n))),np.sin(np.radians(360-i*(360/n)))]))
    return v

def ctrl_pts(n):
    assert n > 2, 'n has to be greater or equal to 3'
    rp = circ_pts(n)
    v = []
    for i in range(n-2):
        v.append(cont_pt(rp[i], rp[i+1], rp[i+2]))
    v.append(cont_pt(rp[n-2], rp[n-1], rp[0]))
    v.append(cont_pt(rp[n-1], rp[0], rp[1]))
    return v

def get_rho(nt, j):
    '''
    Function to compute rho_{j}
    See ref 2** pg8, eq(19)
    '''
    return (j-1)/(nt-1)

def get_theta(ns, i):
    '''
    Function to compute theta_{i}
    See ref 2** pg 8, eq (20)
    '''
    return (2*np.pi)+(1-2*i)*np.pi/ns

def get_E_col(i, ns):
    '''
    Function to compute the columns of the extraction matrix E_bar
    See ref 2** pg 10, eq (31)
    '''
    AE = np.array([[1/3,0,1/3],[-1/6,np.sqrt(3)/6,1/3],[-1/6,-np.sqrt(3)/6,1/3]])
    b = np.zeros((3,1))
    b[0,0] = np.cos(get_theta(ns, i))
    b[1,0] = np.sin(get_theta(ns, i))
    b[2,0] = 1
    return AE.dot(b)

def E_bar(vp, ns):
    '''
    Function to compute the extraction matrix E_bar
    See ref 2** pg 10, eq (31)
    '''
    # ep = (np.sqrt(3)+1)/6
    # el = (np.sqrt(3)-1)/6
    # EM = np.array([[1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3],[1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3],[1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3]])
    # EM = EM + (1/np.sqrt(2))*np.array([[0,0,0,0,1/3,-1/3,-1/3,1/3],[0,0,0,0,-ep,-el,ep,el],[0,0,0,0,el,ep,-el,-ep]])
    EM = np.zeros((3, ns))
    for i in range(3):
        for j in range(ns):
            EM[i,j] = 1/3
    for i in range(ns):
        EM = np.concatenate((EM, get_E_col(i+1, ns)), axis=1)
    # print(EM)
    return EM
        
def anti_diagonal(k):
    '''
    Function to compute the extraction matrix E_bar
    See ref 2** pg 10, eq (31)
    '''
    J = np.zeros((k,k))
    for i in range(k):
        J[k-i-1, i] = 1
    return J

def H_P(vp1, Delta1, vw1, r1, vp2, Delta2, vw2, r2):
    '''
    Calculate the full tensor-product extraction matrix 
    See ref 2** pg 12, eq (40)
    '''
    A_r2 = A_rho_B(vp2, r2, vw2, Delta2)
    C2 = extraction_mat(A_r2, len(vp2), r2)
    A_r1 = A_rho_B(vp1, r1, vw1, Delta1)
    A_rp1 = A_rho_BPS(vp1, r1, vw1, Delta1)
    C1 = extraction_mat_ps(A_r1, A_rp1, len(vp1), r1[0], r1)
    return np.kron(C2, C1)
    # return np.kron(H_ext(vxi2, vp2, vwe2)[0],H_ext(vxi1, vp1, vwe1)[1])

def ME(vp1, ns, nt):
    '''
    Calculate second block of matrix E, i.e. J_{3}E_barJ_{8}
    See ref 2** pg 12, eq (41)
    '''
    # ns = len(vxi1)
    # print(ns)
    E = E_bar(vp1, ns)
    if (nt > 4):
        M = block_diag(E, np.identity(ns*(nt-4)))
        return block_diag(M, anti_diagonal(3).dot(E.dot(anti_diagonal(2*ns))))
    else: 
        return block_diag(E, anti_diagonal(3).dot(E.dot(anti_diagonal(2*ns))))

# def ME(vp1, ns, nt):
#     '''
#     Calculate second block of matrix E, i.e. J_{3}E_barJ_{8}
#     See ref 2** pg 12, eq (41)
#     '''
#     # ns = len(vxi1)
#     # print(ns)
#     E = E_bar(vp1, ns)
#     print(E.shape)
#     if (nt > 2):
#         return block_diag(E, np.identity(ns*(nt-2)))
#     else: 
#         return 'Invalid nt'

def HE(vp1, Delta1, vw1, r1, vp2, Delta2, vw2, ns, r2, nt):
    '''
    Calculate the product of EH
    See ref 2** pg 12
    '''
    # ns, nt = H(vxi1, vp1, vwe1)[1].shape
    HM = H_P(vp1, Delta1, vw1, r1, vp2, Delta2, vw2, r2)
    E = ME(vp1, ns, nt)
    return E.dot(HM)

def M_b_pol_sp(vp1, tau_1, Delta1, vw1, lt1, vp2, tau_2, Delta2, vw2, lt2):
    Ms, cs = get_matrix_b_mu(vp1, Delta1, tau_1, vw1, lt1)
    Mt, ct = get_matrix_b_mu(vp2, Delta2, tau_2, vw2, lt2)
    print(cs)
    print(ct)
    X, Y = np.meshgrid(cs, ct)
    print(X.shape)
    print(Y.shape)
    # print(cs)
    # print(ct)
    rMs, cMs = Ms.shape
    rMt, cMt = Mt.shape
    # print(rMs, cMs)
    # print(rMt, cMt)
    M = []
    for s in range(cMs):
        for t in range(cMt):
            b = np.zeros(rMs*rMt)
            for j in range(rMt):
                for i in range(rMs):
                    b[(i)+j*rMs] = Ms[i,s]*Mt[j,t]
            M.append(b)
    M = np.array(M)
    print(M.T.shape)
    return M.T

def check_col(M):
    r,c = M.shape
    for j in range(c):
        for i in range(r):
            if (M[i,j] != 0):
                print(M[i,j])
    return True

# def plot_t(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2, ax, ay, az):
#     f1 = np.array([0, 2*np.sqrt(2)*ay, az])
#     f2 = np.array([-np.sqrt(6)*ax, -np.sqrt(2)*ay, az])
#     f3 = np.array([np.sqrt(6)*ax, -np.sqrt(2)*ay, az])
#     f4 = np.array([-np.sqrt(6)*ax, -np.sqrt(2)*ay, -az])
#     f5 = np.array([np.sqrt(2)*ax, -np.sqrt(2)*ay, -az])
#     f6 = np.array([0, 2*np.sqrt(2)*ay, -az])
#     vf = [f1, f2, f3, f4, f5, f6]
#     Mb = M_b_pol_sp(vp1, vxi1, tau_1, vwe1, lt1, vp2, vxi2, tau_2, vwe2, lt2)
#     # print(Mb)
#     # print(Mb.shape)
#     H = H_P(vxi1, vp1, vwe1, vxi2, vp2, vwe2)
#     # print(H)
#     # print(H.shape)
#     E = ME(vxi1, vp1)
#     # print(E)
#     # print(E.shape)
#     rE, cE = E.shape
#     rH, cH = H.shape
#     rMb, cMb = Mb.shape
#     xcp = []
#     ycp = []
#     zcp = []
#     for st in range(cMb):
#         f = np.zeros(3)
#         for l in range(rE):
#             sE = 0
#             for j in range(cE):
#                 sHb = 0
#                 for k in range(cH):
#                     sHb = sHb + H[j,k]*Mb[k,st]
#                 sE = sE + sHb*E[l,j]
#             f = f + vf[l]*sE
#         xcp.append(f[0])
#         ycp.append(f[1])
#         zcp.append(f[2])
#         # print(f,l)
#     fig = plt.figure()
#     ax = fig.add_subplot(111, projection='3d')
#     ax.scatter(xcp,ycp,zcp)
#     plt.show()
def Mat_N_bas_qua_pts(vp1, tau_1, Delta1, vw1, num_q1, r1, vp2, tau_2, Delta2, vw2, num_q2, r2):
    Ms, cs, weights_c = get_matrix_b_mu_qp(vp1, Delta1, tau_1, vw1, lt1, num_q1)
    Mt, ct, weights_t = get_matrix_b_mu_qp(vp2, Delta2, tau_2, vw2, lt2, num_q2)
    H = H_P(vp1, Delta1, vw1, r1, vp2, Delta2, vw2, r2)
    A_r2 = A_rho_B(vp2, r2, vw2, Delta2)
    Haux = extraction_mat(A_r2, len(vp2), r2)
    A_r1 = A_rho_B(vp1, r1, vw1, Delta1)
    A_rp1 = A_rho_BPS(vp1, r1, vw1, Delta1)
    Haux1 = extraction_mat_ps(A_r1, A_rp1, len(vp1), r1[0], r1)
    nt, cH1 = Haux1.shape
    ns, cH = Haux.shape
    E = ME(vp1, ns, nt)
    rE, cE = E.shape
    rMs, cMs = Ms.shape
    rMt, cMt = Mt.shape
    vec_N = []
    for l in range(rE):
        N_l = np.zeros((cMs, cMt))
        for s in range(cMs):
            for t in range(cMt):
                b = np.zeros(rMs*rMt)
                for j in range(rMt):
                    for i in range(rMs):
                        b[(i)+j*rMs] = Ms[i,s]*Mt[j,t]
                b = np.array(b).T
                N_l[s,t] = E[l,:].dot(H.dot(b))
        vec_N.append(N_l)
    return vec_N, weights_c, weights_t, cs, ct

def inner_pr_2d(N1, N2, weights_c, weights_t):
    nr, nc = N1.shape
    I1 = 0
    for i in range(nr):
        I2 = 0
        for j in range(nc):
            I2 = I2 + weights_c[i]*weights_t[j]*N1[i,j]*N2[i,j]
        I1 = I1 + I2
    return I1

def inner_pr_2d_vf(N, f_x, f_y, weights_c, weights_t, cs, ct):
    nr, nc = N.shape
    I1 = 0
    # print(f_x, f_y)
    for i in range(nr):
        I2 = 0
        for j in range(nc):
            I2 = I2 + weights_c[i]*weights_t[j]*N[i,j]*f_x(cs[i])*f_y(ct[j])
        I1 = I1 + I2
    return I1

def L2_innerp_error(w, f, weights):
    s = 0
    for i in range(w.shape[0]):
        s = s + weights[i]*(w[i]-f[i])
    return s**2

def L2_project_sphe(vp1, tau_1, Delta1, vw1, num_q1, r1, vp2, tau_2, Delta2, vw2, num_q2, r2):               
    vec_N, weights_c, weights_t, cs, ct = Mat_N_bas_qua_pts(vp1, tau_1, Delta1, vw1, num_q1, r1, vp2, tau_2, Delta2, vw2, num_q2, r2)
    n = len(vec_N)
    A = np.zeros((n,n))
    v1 = np.zeros((n,1))
    v2 = np.zeros((n,1))
    v3 = np.zeros((n,1))
    for i in range(n):
        for j in range(n):
            A[i,j] = inner_pr_2d(vec_N[i], vec_N[j], weights_c, weights_t)
        v1[i] = inner_pr_2d_vf(vec_N[i], np.cos, np.sin, weights_c, weights_t, cs, ct)
        v2[i] = inner_pr_2d_vf(vec_N[i], np.sin, np.sin, weights_c, weights_t, cs, ct)
        v3[i] = inner_pr_2d_vf(vec_N[i], fc1, np.cos, weights_c, weights_t, cs, ct)
    Ainv = np.linalg.pinv(A)
    r1 = Ainv.dot(v1)
    r2 = Ainv.dot(v2)
    r3 = Ainv.dot(v3)
    # error1 = L2_innerp_error(r1, v1, weights_c)
    # error2 = L2_innerp_error(r2, v2, weights_c)
    # error3 = L2_innerp_error(r3, v3, weights_c)
    # print(np.cos, np.sin, error1)
    # print(np.sin, np.sin, error2)
    # print(np.cos, error3)
    Mv = r1
    Mv = np.concatenate((Mv, r2), axis=1)
    Mv = np.concatenate((Mv, r3), axis=1)
    return Mv
            
def fc1(x):
    return 1

def plot_t_1(vp1, tau_1, Delta1, vw1, lt1, r1, vp2, tau_2, Delta2, vw2, lt2, r2, ax, ay, az, Mf, num_q1, num_q2):
    '''
    Calculate ellipsoids (and as a special case also spheres) built using the C1 polar spline
    Plot of arbitrary ellipsoids using smooth polar splines.
    See ref 2** pg 12, eq (40)
    ''' 
    Ms, cs = get_matrix_b_mu(vp1, Delta1, tau_1, vw1, lt1)
    Mt, ct = get_matrix_b_mu(vp2, Delta2, tau_2, vw2, lt2)
    Mf = L2_project_sphe(vp1, tau_1, Delta1, vw1, num_q1, r1, vp2, tau_2, Delta2, vw2, num_q2, r2)
    # Ms, cs, weights_s = get_matrix_b_mu_qp(vp1, Delta1, tau_1, vw1, lt1, 30)
    # Mt, ct, weights_t = get_matrix_b_mu_qp(vp2, Delta2, tau_2, vw2, lt2, 30)
    X, Y = np.meshgrid(cs, ct)
    # Mb = 1
    H = H_P(vp1, Delta1, vw1, r1, vp2, Delta2, vw2, r2)
    A_r2 = A_rho_B(vp2, r2, vw2, Delta2)
    Haux = extraction_mat(A_r2, len(vp2), r2)
    A_r1 = A_rho_B(vp1, r1, vw1, Delta1)
    A_rp1 = A_rho_BPS(vp1, r1, vw1, Delta1)
    Haux1 = extraction_mat_ps(A_r1, A_rp1, len(vp1), r1[0], r1)
    # Haux = H_e_m(vp1, Delta1, vw1, r1)[1] 
    # Haux1 = H_e_m(vp2, Delta2, vw2, r2)[0]
    nt, cH1 = Haux1.shape
    ns, cH = Haux.shape
    # print(nt, cH1)
    # print(ns, cH)
    # print(ns)
    E = ME(vp1, ns, nt)
    rE, cE = E.shape
    # rMb, cMb = Mb.shape
    rrH, ccH = H.shape
    rMf, cMf = (Mf.T).shape
    # print(rMb, cMb, 'Mb')
    # print(rrH, ccH, 'H')
    # print(rE, cE, 'E')
    # print((Mf.T).shape)
    xcp = []
    ycp = []
    zcp = []
    xc = [Mf[i][0] for i in range(rMf)]
    yc = [Mf[i][1] for i in range(rMf)]
    zc = [Mf[i][2] for i in range(rMf)]
    xc1 = [Mf[i][0] for i in range(rMf,cMf)]
    yc1 = [Mf[i][1] for i in range(rMf,cMf)]
    zc1 = [Mf[i][2] for i in range(rMf,cMf)]
    xc.append(Mf[0][0])
    yc.append(Mf[0][1])
    zc.append(Mf[0][2])
    xc1.append(Mf[3][0])
    yc1.append(Mf[3][1])
    zc1.append(Mf[3][2])
    # print(xc)
    # print(yc)
    # print(zc)
    # print(xc1)
    # print(yc1)
    # print(zc1)
    # M = []
    rMs, cMs = Ms.shape
    rMt, cMt = Mt.shape
    X = np.zeros((cMs, cMt))
    Y = np.zeros((cMs, cMt))
    Z = np.zeros((cMs, cMt))
    for s in range(cMs):
        for t in range(cMt):
            b = np.zeros(rMs*rMt)
            for j in range(rMt):
                for i in range(rMs):
                    b[(i)+j*rMs] = Ms[i,s]*Mt[j,t]
            b = np.array(b).T
            f = (Mf.T).dot(E.dot(H.dot(b)))
            X[s, t] = f[0]
            Y[s, t] = f[1]
            Z[s, t] = f[2]
            # print(f[0])
            xcp.append(f[0])
            ycp.append(f[1])
            zcp.append(f[2])
    # print(xcp)
    # print(ycp)
    # print(zcp)
    # print(MA1)
    # print(MA2)
    # print(MA3)
    fig = plt.figure()
    ax = fig.add_subplot(projection="3d")
    
    
    ax.view_init(30, 30)
    ax.set_xlim(-2, 2); ax.set_ylim(-2, 2); ax.set_zlim(-3/2, 3/2);
    ax.scatter(xc1,yc1,zc1)
    # ax.set_axis_off()
    plt.plot(xc1, yc1, zc1,zorder = 0.5)
    
    ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                    cmap='plasma', edgecolor='none', zorder = 0.3, alpha=0.6)
    ax.scatter(xc,yc,zc)
    plt.plot(xc, yc, zc, zorder = 0.1)
    ####Sphere
    # u, v = np.mgrid[0:2 * np.pi:30j, 0:np.pi:20j]
    # x = np.cos(u) * np.sin(v)
    # y = np.sin(u) * np.sin(v)
    # z = np.cos(v)
    # ax.plot_surface(x, y, z, cmap=plt.cm.YlGnBu_r)
    # plt.show()
    
    
    
numb_local_berst1 = 4
vp1 = [2]*numb_local_berst1 
# Delta1 = [0,1,2,3,4]
Delta1 = np.linspace(0, 2*np.pi, len(vp1)+1, endpoint=True) 
m1 = len(vp1)
r1 = [1]*(len(vp1)+1)
# r1 = [1,1,1,1,1]
tau_1 = 0
vw1 = 1
numb_local_berst2 = 2
vp2 = [2]*numb_local_berst2 
# Delta2 = [0,1,2]
Delta2 = np.linspace(0, np.pi, len(vp2)+1, endpoint=True) 
m2 = len(vp2)
# r2 = [1,1,1]
r2 = [1]*(len(vp2)+1)
tau_2 = 0
vw2 = 1
lt1 = lt2 = 30
k1 = 1
p1 = 1
ax = 1
ay = 1
az = 1
# Delta = [0,1,2,3,4]
# r = [-1,1,1,1,-1]
# vp = [2,2,2,2]
# m = len(vp)
# print(uv(Delta, vp, r, m))
# print(vv(Delta, vp, r, m))
# print(nf(r, vp, m))
# plott_CB(vp, Delta, tau_1, vw, lt, r)
# plot_b_mu(vp1, Delta1, tau_1, vw1, 100)
# plott_CB(vp1, Delta1, tau_1, vw1, 100, r1)
# plot_b_mu(vp2, Delta2, tau_2, vw2, 100)
# plott_CB(vp2, Delta2, tau_2, vw2, 100, r2)
# get_matrix_b_mu(vp1, Delta1, tau_1, vw1, lt1)
# v = np.linspace(0, 1, 6, endpoint=True)
# print(v)
# w = [r for r in v if r>0.5]
# w = any(r > 0.5 for r in v) 
# print(w)
# newArr = v[(v >= 0.5 ) & (v <= 1)]
# print(newArr)
# print(v)
Mf = np.array([[0, 4*np.sqrt(2)*ay, az], \
                [-4*np.sqrt(6)*ax, -2*np.sqrt(2)*ay, az],\
                    [4*np.sqrt(6)*ax, -2*np.sqrt(2)*ay, az],\
                # [4*np.sqrt(6)*ax, -2*np.sqrt(2)*ay, az+4*ax],\
                [-4*np.sqrt(6)*ax, -2*np.sqrt(2)*ay, -az],\
                [4*np.sqrt(6)*ax, -2*np.sqrt(2)*ay, -az], \
                [0, 4*np.sqrt(2)*ay, -az]]) 
num_q1 = num_q2 = 30
# Mf = L2_project_sphe(vp1, tau_1, Delta1, vw1, num_q1, r1, vp2, tau_2, Delta2, vw2, num_q2, r2)
# print(Mf)
plot_t_1(vp1, tau_1, Delta1, vw1, lt1, r1, vp2, tau_2, Delta2, vw2, lt2, r2, ax, ay, az, Mf, num_q1, num_q2)
